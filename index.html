<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve-Crash: CTF Echo</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            overflow: hidden;
            font-size: 0.9em;
        }
        
        canvas {
            background-color: #0a0a0a;
            border: 1px solid #333;
            filter: drop-shadow(0 0 10px #555);
            cursor: pointer;
        }
        #ui {
            display: flex;
            justify-content: space-between;
            width: 640px;
            padding: 5px;
            box-sizing: border-box;
        }
        .player-info { 
            flex-basis: 45%; 
            transition: color 0.2s ease;
        }
        #p1-info { color: #00ffff; text-align: left; }
        #p2-info { color: #ff00ff; text-align: right; }
        .score { font-size: 2.0em; font-weight: bold; }
        .boost-meter {
            width: 100%;
            height: 8px;
            background-color: #333;
            border: 1px solid #555;
            margin-top: 3px;
        }
        .boost-bar {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear, background-color 0.2s ease;
        }
        #p1-boost-bar { background-color: #00ffff; }
        #p2-boost-bar { background-color: #ff00ff; }
        
        #message {
            font-size: 1.2em;
            text-align: center;
            line-height: 1.4;
            text-shadow: 0 0 10px #fff;
            display: none;
            padding: 5px 0;
            width: 640px;
        }
        
        #arena-name {
            font-size: 1em;
            color: #888;
            width: 640px;
            text-align: center;
            height: 1.2em;
        }
        #game-mode {
            font-size: 1.2em;
            color: #fff;
            text-shadow: 0 0 5px #ff0;
            margin-bottom: 5px;
            text-align: center;
            width: 640px;
        }
        /* Style for CTF Timer in-game */
        #ctf-timer {
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px #f00;
            text-align: center;
            width: 640px;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="p1-info" class="player-info">
            <div class="score" id="p1-score">0</div>
            <div>PLAYER 1 (WASD)</div>
            <div class="boost-meter"><div class="boost-bar" id="p1-boost-bar"></div></div>
        </div>
        <div id="p2-info" class="player-info">
            <div class="score" id="p2-score">0</div>
            <div>PLAYER 2 (ARROWS)</div>
            <div class="boost-meter"><div class="boost-bar" id="p2-boost-bar"></div></div>
        </div>
    </div>
    
    <div id="message"></div>
    
    <div id="arena-name"></div>

    <div id="game-mode"></div>
    <div id="ctf-timer" style="display: none;"></div>
    
    <canvas id="gameCanvas" width="640" height="400"></canvas>

    <script>
        // --- 1. SETUP & CONSTANTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        const p1BoostEl = document.getElementById('p1-boost-bar');
        const p2BoostEl = document.getElementById('p2-boost-bar');
        const p1InfoEl = document.getElementById('p1-info');
        const p2InfoEl = document.getElementById('p2-info');
        const messageEl = document.getElementById('message');
        const arenaNameEl = document.getElementById('arena-name');
        const gameModeEl = document.getElementById('game-mode');
        const ctfTimerEl = document.getElementById('ctf-timer');
        
        const FPS = 60;
        const PLAYER_SIZE = 10;
        const PLAYER_SPEED = 2;
        const BOOST_SPEED = 4;
        const BRAKE_SPEED = 1;
        const TURN_SPEED = 0.08;
        const BOOST_DURATION = 1 * FPS;
        const BOOST_COOLDOWN = 4 * FPS;
        const TRAIL_LIFETIME = 8 * FPS;
        const TRAIL_WIDTH = 4;
        const SPAWN_IMMUNITY_TIME = 60;
        
        // --- CTF CONSTANTS ---
        const CTF_ROUND_TIME = 120 * FPS; // 2 minutes in frames
        const FLAG_RADIUS = 10;
        const P1_HOME_X = 80;
        const P2_HOME_X = 640 - 80;
        const RESPAWN_TIME = 2 * FPS; // 2 seconds respawn delay

        const colorPalette = [
            '#00ffff', '#ff00ff', '#00ff00', '#ffff00', '#ff8000',
            '#ffffff', '#ff0000', '#0080ff', '#8000ff', '#008000'
        ];
        
        // --- GAME MODE LIST (CTF Only) ---
        const MODES = ['CTF MODE']; 
        let p1ModeIndex = 0; 
        let p2ModeIndex = 0; 
        
        let p1ColorIndex = 0;
        let p2ColorIndex = 1;
        let p1Ready = false;
        let p2Ready = false;

        let gameState = 'start';
        let trails = [];
        let particles = [];
        let keys = {};
        let player1, player2;
        
        // --- CTF Variables ---
        let gameMode = 'CTF MODE';
        let p1Flag, p2Flag;
        let ctfRoundTimer = CTF_ROUND_TIME;
        let p1RoundScore = 0;
        let p2RoundScore = 0;
        
        const arenas = [
            { name: "The Classic", obstacles: [], wrapWalls: false },
            { name: "The Pillars", obstacles: [ { x: 200, y: 100, width: 40, height: 200 }, { x: 400, y: 100, width: 40, height: 200 } ], wrapWalls: false },
            { name: "The Hourglass", obstacles: [ { x: 0, y: 0, width: 220, height: 100 }, { x: 420, y: 0, width: 220, height: 100 }, { x: 0, y: 300, width: 220, height: 100 }, { x: 420, y: 300, width: 220, height: 100 } ], wrapWalls: false },
            { name: "The Open", obstacles: [], wrapWalls: true }
        ];
        // Set initial arena index to 'The Pillars' (index 1)
        let currentArenaIndex = 1; 
        let currentArena = arenas[currentArenaIndex];

        // --- 2. INPUT HANDLING ---

        window.addEventListener('keydown', (e) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space", "a", "d", "w", "s"].includes(e.key)) {
                e.preventDefault();
            }
            if (gameState === 'colorSelect') {
                handleColorKeys(e.key);
            } else if (gameState === 'modeSelect') {
                handleModeKeys(e.key);
            }
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('click', () => {
            if (gameState === 'start') {
                gameState = 'modeSelect';
                updateModeMessage();
            } else if (gameState === 'gameOver') {
                initGame();
            }
        });

        // --- 3. PLAYER CLASS (Updated for Respawn) ---
        class Player {
            constructor(x, y, angle, color, controls, isP1, homeX) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.color = color;
                this.controls = controls;
                this.speed = PLAYER_SPEED;
                this.isBoosting = false;
                this.boostTimer = 0;
                this.boostCooldownTimer = BOOST_COOLDOWN;
                this.isBraking = false;
                this.isDead = false;
                this.score = 0;
                this.immunityTimer = 0;
                this.isP1 = isP1;
                this.carryingFlag = null;
                this.respawnTimer = 0; // NEW: Respawn timer
                this.homeX = homeX;
            }

            update() {
                if (this.isDead) {
                    // NEW: Handle respawn timer
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) {
                        this.respawn();
                    }
                    return;
                }
                
                if (this.immunityTimer > 0) { this.immunityTimer--; }
                if (keys[this.controls.left]) { this.angle -= TURN_SPEED; }
                if (keys[this.controls.right]) { this.angle += TURN_SPEED; }
                
                if (keys[this.controls.up] && this.boostCooldownTimer >= BOOST_COOLDOWN) {
                    this.isBoosting = true;
                    this.boostTimer = BOOST_DURATION;
                    this.boostCooldownTimer = 0;
                }
                this.isBraking = keys[this.controls.down] && !this.isBoosting;
                if (this.isBoosting) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) { this.isBoosting = false; }
                } else {
                    if (this.boostCooldownTimer < BOOST_COOLDOWN) { this.boostCooldownTimer++; }
                }
                if (this.isBoosting) { this.speed = BOOST_SPEED; }
                else if (this.isBraking) { this.speed = BRAKE_SPEED; }
                else { this.speed = PLAYER_SPEED; }
                
                const moveX = Math.cos(this.angle) * this.speed;
                const moveY = Math.sin(this.angle) * this.speed;
                
                trails.push(new TrailSegment(this.x, this.y, this.color));

                this.x += moveX;
                this.y += moveY;
                
                this.checkWallCollision();
                this.checkObstacleCollision();
                this.checkTrailCollision();
                
                this.checkFlagInteraction();
                
                if (this.carryingFlag) {
                    this.carryingFlag.x = this.x;
                    this.carryingFlag.y = this.y;
                }
            }
            
            checkFlagInteraction() {
                const homeFlag = this.isP1 ? p1Flag : p2Flag;
                const enemyFlag = this.isP1 ? p2Flag : p1Flag;
                
                // 1. Capture Enemy Flag
                if (!this.carryingFlag && !enemyFlag.isCarried) {
                    const dist = Math.sqrt(Math.pow(this.x - enemyFlag.x, 2) + Math.pow(this.y - enemyFlag.y, 2));
                    if (dist < PLAYER_SIZE + FLAG_RADIUS) {
                        this.carryingFlag = enemyFlag;
                        enemyFlag.isCarried = true;
                    }
                }
                
                // 2. Score with Flag
                if (this.carryingFlag && this.carryingFlag.isP1 !== this.isP1) {
                    if (Math.abs(this.x - this.homeX) < 60) {
                        this.isP1 ? p1RoundScore++ : p2RoundScore++;
                        
                        this.carryingFlag.isCarried = false;
                        this.carryingFlag = null;
                        this.isP1 ? p2Flag.reset() : p1Flag.reset();
                        
                        showMessage(`${this.isP1 ? 'PLAYER 1' : 'PLAYER 2'} SCORED! (Score: ${this.isP1 ? p1RoundScore : p2RoundScore})`);
                        setTimeout(hideMessage, 1000);
                    }
                }
                
                // 3. Return your own dropped flag
                if (homeFlag.isDropped && !this.carryingFlag) {
                    const dist = Math.sqrt(Math.pow(this.x - homeFlag.x, 2) + Math.pow(this.y - homeFlag.y, 2));
                    if (dist < PLAYER_SIZE + FLAG_RADIUS) {
                        homeFlag.reset();
                        showMessage(`${this.isP1 ? 'P1' : 'P2'} RETURNED THEIR FLAG!`);
                        setTimeout(hideMessage, 1000);
                    }
                }
            }

            checkWallCollision() {
                if (this.immunityTimer > 0) return;
                if (currentArena.wrapWalls) {
                    if (this.x < 0) this.x = canvas.width;
                    if (this.x > canvas.width) this.x = 0;
                    if (this.y < 0) this.y = canvas.height;
                    if (this.y > canvas.height) this.y = 0;
                } else {
                    if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                        this.die();
                    }
                }
            }

            checkObstacleCollision() {
                if (this.immunityTimer > 0) return;
                const playerRadius = PLAYER_SIZE / 2;
                for (let obs of currentArena.obstacles) {
                    if (this.x + playerRadius > obs.x &&
                        this.x - playerRadius < obs.x + obs.width &&
                        this.y + playerRadius > obs.y &&
                        this.y - playerRadius < obs.y + obs.height) {
                        this.die();
                        break;
                    }
                }
            }

            checkTrailCollision() {
                if (this.immunityTimer > 0) return;
                const playerRadius = PLAYER_SIZE / 2;
                const trailRadius = TRAIL_WIDTH / 2;
                const collisionThreshold = playerRadius + trailRadius;

                for (let segment of trails) {
                    if (segment.color === this.color && segment.lifetime > TRAIL_LIFETIME - 15) {
                        continue;
                    }
                    const dx = this.x - segment.x;
                    const dy = this.y - segment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < collisionThreshold) { 
                        this.die();
                        break;
                    }
                }
            }

            die() {
                if (this.isDead) return; // Prevent double death
                this.isDead = true;
                this.respawnTimer = RESPAWN_TIME; // Start 2-second respawn timer
                
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(this.x, this.y, this.color));
                }
                this.speed = 0;
                
                if (this.carryingFlag) {
                    this.carryingFlag.isCarried = false;
                    this.carryingFlag.isDropped = true;
                    this.carryingFlag = null;
                }
            }
            
            // NEW: Respawn function
            respawn() {
                this.isDead = false;
                this.respawnTimer = 0;
                this.x = this.homeX;
                this.y = canvas.height / 2;
                this.angle = this.isP1 ? 0 : Math.PI;
                this.immunityTimer = SPAWN_IMMUNITY_TIME;
                this.boostCooldownTimer = BOOST_COOLDOWN;
            }

            draw() {
                if (this.isDead) return;
                
                let draw = true;
                // Flashing for immunity
                if (this.immunityTimer > 0 && Math.floor(this.immunityTimer / 6) % 2 === 0) {
                    draw = false;
                }
                
                // Shadow for flag carrier
                if (this.carryingFlag) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 20;
                    draw = true;
                }

                if (draw) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(PLAYER_SIZE, 0);
                    ctx.lineTo(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2);
                    ctx.lineTo(-PLAYER_SIZE / 2, PLAYER_SIZE / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                ctx.shadowBlur = 0;
                
                if (this.carryingFlag) {
                    this.carryingFlag.drawSymbol(this.x, this.y - 20);
                }
            }

            drawBoostBar(element) {
                let percent = (this.boostCooldownTimer / BOOST_COOLDOWN) * 100;
                if (this.isBoosting) {
                    percent = (this.boostTimer / BOOST_DURATION) * 100;
                }
                element.style.width = `${percent}%`;
            }
        }
        
        class Flag {
            // ... (Flag class remains the same)
            constructor(x, y, color, isP1Flag) {
                this.initialX = x;
                this.initialY = y;
                this.x = x;
                this.y = y;
                this.color = color;
                this.isP1 = isP1Flag; 
                this.isCarried = false;
                this.isDropped = false;
            }
            
            reset() {
                this.x = this.initialX;
                this.y = this.initialY;
                this.isCarried = false;
                this.isDropped = false;
            }

            draw() {
                if (this.isCarried) return;
                
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;

                ctx.fillRect(this.x - 1, this.y, 2, 20);
                
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                
                const direction = this.isP1 ? 1 : -1;
                ctx.lineTo(this.x + FLAG_RADIUS * 2 * direction, this.y + FLAG_RADIUS);
                ctx.lineTo(this.x, this.y + FLAG_RADIUS);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
            
            drawSymbol(x, y) {
                 ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + FLAG_RADIUS, y + FLAG_RADIUS / 2);
                ctx.lineTo(x, y + FLAG_RADIUS / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        
        class TrailSegment {
            // ... (TrailSegment class remains the same)
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.lifetime = TRAIL_LIFETIME;
            }
            update() { 
                this.lifetime--; 
            }
            draw() {
                const alpha = this.lifetime / TRAIL_LIFETIME;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TRAIL_WIDTH / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Particle {
            // ... (Particle class remains the same)
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                this.lifetime = 60;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.lifetime--;
            }
            draw() {
                const alpha = this.lifetime / 60;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // --- 4. GAME MODE SELECTION LOGIC (Simplified for CTF Only) ---

        function handleModeKeys(key) {
            // Since there's only one mode, clicking ready immediately proceeds
            if (key === 'w') { p1Ready = true; }
            if (key === 's') { p1Ready = false; }
            if (key === 'ArrowUp') { p2Ready = true; }
            if (key === 'ArrowDown') { p2Ready = false; }

            updateModeMessage();

            if (p1Ready && p2Ready) {
                gameMode = MODES[p1ModeIndex];
                gameState = 'colorSelect';
                p1Ready = false; 
                p2Ready = false;
                updateReadyMessage(); 
            }
        }
        
        function updateModeMessage() {
            let p1Text = p1Ready ? "P1: READY" : `P1: CTF MODE`;
            let p2Text = p2Ready ? "P2: READY" : `P2: CTF MODE`;
            showMessage(`SELECT GAME MODE\n${p1Text} | ${p2Text}\n(W/UP to Ready)`);
        }

        // --- 5. GAME LOGIC & STATE ---
        
        function handleColorKeys(key) {
            if (key === 'a' && !p1Ready) {
                p1ColorIndex = (p1ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                if (p1ColorIndex === p2ColorIndex) {
                    p1ColorIndex = (p1ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                }
            }
            if (key === 'd' && !p1Ready) {
                p1ColorIndex = (p1ColorIndex + 1) % colorPalette.length;
                if (p1ColorIndex === p2ColorIndex) {
                    p1ColorIndex = (p1ColorIndex + 1) % colorPalette.length;
                }
            }
            if (key === 'w') { p1Ready = true; }
            if (key === 's') { p1Ready = false; }

            if (key === 'ArrowLeft' && !p2Ready) {
                p2ColorIndex = (p2ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                if (p2ColorIndex === p1ColorIndex) {
                    p2ColorIndex = (p2ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                }
            }
            if (key === 'ArrowRight' && !p2Ready) {
                p2ColorIndex = (p2ColorIndex + 1) % colorPalette.length;
                if (p2ColorIndex === p1ColorIndex) {
                    p2ColorIndex = (p2ColorIndex + 1) % colorPalette.length;
                }
            }
            if (key === 'ArrowUp') { p2Ready = true; }
            if (key === 'ArrowDown') { p2Ready = false; }

            updateColorUI();
            updateReadyMessage();

            if (p1Ready && p2Ready) {
                proceedToStart();
            }
        }

        function updateColorUI() {
            const p1Color = colorPalette[p1ColorIndex];
            const p2Color = colorPalette[p2ColorIndex];
            p1InfoEl.style.color = p1Color;
            p2InfoEl.style.color = p2Color;
            p1BoostEl.style.backgroundColor = p1Color;
            p2BoostEl.style.backgroundColor = p2Color;
        }

        function updateReadyMessage() {
            let p1Text = p1Ready ? "P1: READY" : "P1: <A/D> Select";
            let p2Text = p2Ready ? "P2: READY" : "P2: <L/R> Select";
            showMessage(`CHOOSE COLOR\n${p1Text} | ${p2Text}\n(W/UP to Ready, S/DOWN to Unready)`);
        }

        function proceedToStart() {
            // Update player colors based on selection
            player1.color = colorPalette[p1ColorIndex];
            player2.color = colorPalette[p2ColorIndex];
            // Update player class to set colors
            player1.respawn(); // Reset player position with new color
            player2.respawn();
            startGame(); 
        }

        function initGame() {
            // Set up players using P1_HOME_X/P2_HOME_X
            player1 = new Player(P1_HOME_X, canvas.height / 2, 0, colorPalette[p1ColorIndex], { up: 'w', down: 's', left: 'a', right: 'd' }, true, P1_HOME_X);
            player2 = new Player(P2_HOME_X, canvas.height / 2, Math.PI, colorPalette[p2ColorIndex], { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, false, P2_HOME_X);
            
            p1RoundScore = 0; // Reset overall scores
            p2RoundScore = 0;
            updateScoreUI();
            
            // Set fixed CTF setup
            currentArenaIndex = 1; // "The Pillars"
            currentArena = arenas[currentArenaIndex];
            gameMode = 'CTF MODE';

            gameState = 'modeSelect'; 
            p1Ready = false;
            p2Ready = false;
            updateModeMessage();
            arenaNameEl.textContent = "";
        }
        
        function startGame() {
            gameModeEl.textContent = gameMode;
            
            trails = [];
            particles = [];
            
            ctfRoundTimer = CTF_ROUND_TIME;
            
            p1Flag = new Flag(P1_HOME_X, canvas.height / 2, player1.color, true);
            p2Flag = new Flag(P2_HOME_X, canvas.height / 2, player2.color, false);
            ctfTimerEl.style.display = 'block';

            currentArena = arenas[currentArenaIndex];
            arenaNameEl.textContent = currentArena.name;
            
            // Initial spawn
            player1.respawn();
            player2.respawn();
            
            startCountdown();
        }

        function startCountdown() {
            gameState = 'countdown';
            setTimeout(() => { arenaNameEl.textContent = ""; gameModeEl.textContent = gameMode; }, 2000); 
            
            let count = 3;
            showMessage(count);
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    showMessage(count);
                } else {
                    showMessage('GO!');
                    clearInterval(timer);
                    setTimeout(() => {
                        gameState = 'playing';
                        hideMessage();
                    }, 500);
                }
            }, 1000);
        }

        // --- UPDATED: handleRoundOver now handles end of game for CTF timer ---
        function handleGameOverByTimer() {
            gameState = 'gameOver';
            
            let message = '';
            if (p1RoundScore > p2RoundScore) {
                message = `PLAYER 1 WINS! (${p1RoundScore}-${p2RoundScore})`;
            } else if (p2RoundScore > p1RoundScore) {
                message = `PLAYER 2 WINS! (${p1RoundScore}-${p2RoundScore})`;
            } else {
                message = 'GAME TIME UP: TIE!';
            }
            
            showMessage(`${message}\n(Click to Restart)`);
            updateScoreUI();
        }
        
        function updateScoreUI() {
            p1ScoreEl.textContent = p1RoundScore; // Display round score as main score
            p2ScoreEl.textContent = p2RoundScore;
        }

        function showMessage(text) {
            messageEl.innerHTML = text.toString().replace(/\n/g, '<br>');
            messageEl.style.display = 'block';
        }

        function hideMessage() {
            messageEl.style.display = 'none';
        }
        
        function drawArena() {
            ctx.fillStyle = '#888';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            for (let obs of currentArena.obstacles) {
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            }
            ctx.shadowBlur = 0;
        }

        // --- 6. MAIN GAME LOOP ---
        function gameLoop() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawArena();
            
            if (gameState === 'playing') {
                player1.update();
                player2.update();

                // CTF Timer Logic
                ctfRoundTimer--;
                const seconds = Math.ceil(ctfRoundTimer / 60);
                const minutes = Math.floor(seconds / 60);
                const displaySeconds = seconds % 60;
                ctfTimerEl.textContent = `TIME: ${minutes}:${displaySeconds < 10 ? '0' : ''}${displaySeconds} (P1: ${p1RoundScore} | P2: ${p2RoundScore})`;

                if (ctfRoundTimer <= 0) {
                    handleGameOverByTimer();
                }
            }
            
            // Draw Trails, Particles, and Players
            for (let i = trails.length - 1; i >= 0; i--) {
                trails[i].update();
                if (trails[i].lifetime <= 0) { trails.splice(i, 1); }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].lifetime <= 0) { particles.splice(i, 1); }
            }

            for (let segment of trails) { segment.draw(); }
            
            if (p1Flag) p1Flag.draw();
            if (p2Flag) p2Flag.draw();
            
            if (gameState === 'playing' || gameState === 'countdown' || gameState === 'colorSelect' || gameState === 'modeSelect') {
                player1.draw();
                player2.draw();
            }
            for (let particle of particles) { particle.draw(); }
            
            player1.drawBoostBar(p1BoostEl);
            player2.drawBoostBar(p2BoostEl);

            requestAnimationFrame(gameLoop);
        }

        // --- 7. START THE GAME ---
        initGame();
        gameLoop();
    </script>
</body>
</html>
